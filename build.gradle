// PygmyMarmoset gradle build script

///////////////////////////////////////////////////////////////////////
// Tasks
///////////////////////////////////////////////////////////////////////

task uberJar(
	type: Jar,
	dependsOn: [
		':copyWebappClasses',
		':copyConfigProperties',
		':copyWebappWebinf',
		':copyWebappFiles',
		':copyWebappJars',
		':copyLauncherFiles',
		':copyJettyDeps']) {
	manifest {
		attributes 'Main-Class' : 'edu.ycp.cs.pygmymarmoset.main.UberjarMain'
	}
	baseName 'build/pygmyMarmosetApp'
	from 'build/uberJarStaging'
}

// Copy all web app classes and resources into the uberjar staging area.
task copyWebappClasses(
	type: Copy,
	dependsOn: [
		':copyWebappProjectJars', // ensures depended-on classes are available
		':PygmyMarmosetWebapp:compileJava'
	]){
	from 'PygmyMarmosetWebapp/war/WEB-INF/classes'
	into 'build/uberJarStaging/war/WEB-INF/classes'
	exclude "pygmymarmoset.properties"
}

task buildModelClassesJar(dependsOn: [':PygmyMarmosetModelClasses:jar']) { }

task buildPersistenceJar(dependsOn: [':buildModelClassesJar', ':PygmyMarmosetPersistence:jar']) {
	// persistence jar can't be built until model classes jar is built
	mustRunAfter ':buildModelClassesJar'
}

task buildControllersJar(dependsOn: [':buildPersistenceJar', ':PygmyMarmosetControllers:jar']) {
	// controllers jar can't be built until persistence jar is built
	mustRunAfter ':buildPersistenceJar'
}

// Copy jars of projects depended on by the webapp into the uberjar
// staging area.
task copyWebappProjectJars(
	type: Copy,
	dependsOn: [
		':buildControllersJar' // ensures model classes and persistence jars are build, too
	]) {
	from 'PygmyMarmosetModelClasses/build/libs', 'PygmyMarmosetPersistence/build/libs',
					'PygmyMarmosetControllers/build/libs'
	into 'build/uberJarStaging/war/WEB-INF/lib'
	include '*.jar'
}

// Copy the configuration properties
task copyConfigProperties(type: Copy) {
	from project.projectDir
	into 'build/uberJarStaging/war/WEB-INF/classes'
	include 'pygmymarmoset.properties'
	
	// make sure there actually was a configuration properties file to copy
	inputs.sourceFiles.stopExecutionIfEmpty()
}

// Copy the non-class and non-jar files in the webapp's WEB-INF
// into the uberjar staging area.
task copyWebappWebinf(type: Copy) {
	from 'PygmyMarmosetWebapp/war/WEB-INF'
	into 'build/uberJarStaging/war/WEB-INF'
	exclude 'classes/**', 'lib/**'
}

// Copy all other webapp files, such as JSPs, images, js, css, etc.
// into the uberjar staging area.
task copyWebappFiles(type: Copy, dependsOn: [':copyJstlTldFiles', ':copyJstlClassFiles']) {
	from 'PygmyMarmosetWebapp/war'
	into 'build/uberJarStaging/war'
	exclude 'WEB-INF/**'
}

// Copy all of the webapp's runtime jar files
// into the uberjar staging area.
task copyWebappJars(type: Copy) {
	from 'PygmyMarmosetWebapp/war/WEB-INF/lib'
	into 'build/uberJarStaging/war/WEB-INF/lib'
}

// Copy the launcher program classfiles into the uberjar staging area.
task copyLauncherFiles(type: Copy, dependsOn: [':PygmyMarmosetLauncher:compileJava']) {
	from 'PygmyMarmosetLauncher/bin'
	into 'build/uberJarStaging'
}

// Copy all of the contents of the Jetty jarfiles into the uberjar staging area.
task copyJettyDeps(type: Copy) {
	from requiredJars(project(':PygmyMarmosetLauncher')).collect { zipTree(it) }
	into 'build/uberJarStaging'
	exclude 'META-INF/**'
}

// Note: the following targets copy the .tld files and classfiles
// for Apache JSTL into the webapp.  Getting them to resolve
// correctly when running from the uberjar is complicated and
// would involve classloader hacks.  This solution is easy
// and works.

task explodeJstl(type: Copy) {
	from zipTree('Jetty9/lib/apache-jstl/org.apache.taglibs.taglibs-standard-impl-1.2.5.jar')
	into 'build/apache-jstl'
}

task copyJstlTldFiles(type: Copy, dependsOn: [':explodeJstl']) {
	from 'build/apache-jstl/META-INF'
	into 'build/uberJarStaging/war/WEB-INF'
	include '*.tld'
}

task copyJstlClassFiles(type: Copy, dependsOn: [':explodeJstl']) {
	from 'build/apache-jstl'
	into 'build/uberJarStaging/war/WEB-INF/classes'
	include 'org/**'
}

///////////////////////////////////////////////////////////////////////
// Common methods
///////////////////////////////////////////////////////////////////////

// Read an Eclipse classpath and return a list of jarfiles
// and directories.  See:
//   http://stackoverflow.com/questions/31653796
// I improved the basic technique so that referenced projects
// are added to the classpath correctly.
// WARNING: if there are projects with circular dependencies
// this method will execute an infinite recursion.
def parseEclipseClasspath(classpathFile, exportsOnly) {
	def baseDir = classpathFile.parentFile
	
	//println "classpathFile=${classpathFile}"
	def cpXml = new XmlParser().parse(classpathFile)
	def libPaths = []
	def addOutput = false
	def outputDir
	cpXml.classpathentry.each {
		if ('lib' == it.@kind) {
			// reference to jarfile
			def libPath = it.@path
			if (libPath.startsWith("/") && !exportsOnly) {
				// Jar file from another project: is referenced relative
				// to parent directory
				def parentDir = baseDir.parentFile.absolutePath
				libPaths.add(parentDir + libPath)
			} else {
				// Jar file is internal to this project
				def isExport = it.@exported == 'true'
				if (isExport || !exportsOnly) {
					libPaths.add(baseDir.path + '/' + libPath)
				}
			}
		} else if ('src' == it.@kind && !it.@path.startsWith('/') && exportsOnly) {
			// reference to source directory of depended-on project:
			// make a note to add the output directory
			addOutput = true
		} else if ('src' == it.@kind && it.@path.startsWith('/')) {
			// reference to project
			//println "Adding recursive dependencies from ${it.@path}"
			def refProjBase = new File(baseDir.path + '/..' + it.@path).canonicalPath
			//println "refProjBase=${refProjBase}"
			def refLibPaths = parseEclipseClasspath(new File(refProjBase + '/.classpath'), true)
			libPaths.addAll(refLibPaths)
		} else if ('output' == it.@kind) {
			outputDir = baseDir.path + '/' + it.@path
		}
	}
	
	if (addOutput) {
		// Add the output directory (i.e., compiled classfiles for this project)
		libPaths.add(outputDir)
	}
	
	return libPaths
}

// Get compile-time dependencies for specified project
def eclipseClasspath(p) {
	def baseDir = p.projectDir.absolutePath
	def classpathFile = new File(baseDir, '.classpath')
	//println "baseDir=${baseDir}"
	return parseEclipseClasspath(classpathFile, false)
}

// Get just the required jars for a project
def requiredJars(p) {
	return eclipseClasspath(p).findAll {
		it.endsWith('.jar')
	}
}
